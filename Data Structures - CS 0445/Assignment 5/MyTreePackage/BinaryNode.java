// CS 0445 Spring 2015// BinaryNode class for Assignment 5.  Add the methods specified in the// assignment sheet so that this class works correctly.package MyTreePackage;import java.util.Iterator;import java.util.LinkedList;import java.util.Queue;/**   A class that represents nodes in a binary tree.   @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class BinaryNode<T>{   private T             data;   private BinaryNode<T> leftChild;  // Reference to left child   private BinaryNode<T> rightChild; // Reference to right child   private int counter = 0;   public BinaryNode()   {      this(null); // Call next constructor   } // end default constructor   public BinaryNode(T dataPortion)   {      this(dataPortion, null, null); // Call next constructor   } // end constructor   public BinaryNode(T dataPortion, BinaryNode<T> newLeftChild,                                    BinaryNode<T> newRightChild)   {      data = dataPortion;      leftChild = newLeftChild;      rightChild = newRightChild;   } // end constructor   /** Retrieves the data portion of this node.       @return  The object in the data portion of the node. */   public T getData()   {      return data;   } // end getData   /** Sets the data portion of this node.       @param newData  The data object. */   public void setData(T newData)   {      data = newData;   } // end setData   /** Retrieves the left child of this node.       @return  The node’s left child. */   public BinaryNode<T> getLeftChild()   {      return leftChild;   } // end getLeftChild   /** Sets this node’s left child to a given node.       @param newLeftChild  A node that will be the left child. */   public void setLeftChild(BinaryNode<T> newLeftChild)   {      leftChild = newLeftChild;   } // end setLeftChild   /** Detects whether this node has a left child.       @return  True if the node has a left child. */   public boolean hasLeftChild()   {      return leftChild != null;   } // end hasLeftChild   /** Retrieves the right child of this node.       @return  The node’s right child. */   public BinaryNode<T> getRightChild()   {      return rightChild;   } // end getRightChild   /** Sets this node’s right child to a given node.       @param newRightChild  A node that will be the right child. */   public void setRightChild(BinaryNode<T> newRightChild)   {      rightChild = newRightChild;   } // end setRightChild   /** Detects whether this node has a right child.       @return  True if the node has a right child. */   public boolean hasRightChild()   {      return rightChild != null;   } // end hasRightChild   /** Detects whether this node is a leaf.       @return  True if the node is a leaf. */   public boolean isLeaf()   {      return (leftChild == null) && (rightChild == null);   } // end isLeaf   /** Counts the nodes in the subtree rooted at this node.       @return  The number of nodes in the subtree rooted at this node. */   public int getNumberOfNodes()   {      int leftNumber = 0;      int rightNumber = 0;      if (leftChild != null)         leftNumber = leftChild.getNumberOfNodes();      if (rightChild != null)         rightNumber = rightChild.getNumberOfNodes();      return 1 + leftNumber + rightNumber;   } // end getNumberOfNodes   /** Computes the height of the subtree rooted at this node.       @return  The height of the subtree rooted at this node. */   public int getHeight()   {      return getHeight(this); // Call private getHeight   } // end getHeight   private int getHeight(BinaryNode<T> node)   {      int height = 0;      if (node != null)         height = 1 + Math.max(getHeight(node.getLeftChild()),                               getHeight(node.getRightChild()));      return height;   } // end getHeight   /** Copies the subtree rooted at this node.       @return  The root of a copy of the subtree rooted at this node. */   public BinaryNode<T> copy()   {      BinaryNode<T> newRoot = new BinaryNode<>(data);      if (leftChild != null)         newRoot.setLeftChild(leftChild.copy());      if (rightChild != null)         newRoot.setRightChild(rightChild.copy());      return newRoot;   } // end copy   	// **********************************	// Complete the additional methods below	// **********************************   // This method returns true if the tree is a perfect tree.	public boolean isFull()	// If the tree is a full tree, return true	{						// Otherwise, return false.  See notes for							// definition of full.		if (leftChild == null && rightChild == null)			return true;		else if (leftChild == null)			return false;		else if (rightChild == null)			return false;		// This last else if statement makes sure that the tree is balanced as a full		// tree must be balanced. A tree could have all nodes with 0 or 2 children		// but it would not necessarily mean it is full. Checking for balance addresses		// that concern.		else if (isBalanced(0, this))			return leftChild.isFull() && rightChild.isFull();		return false;	}  	public boolean isBalanced(int k)	// Return true if 1) the difference	{	// in height between the left and right subtrees is at most k,		// and 2) the left and right subtrees are both recursively		// k-balanced; return false otherwise		return isBalanced(k, this);	}  	// Recursive method to check if tree is balanced. It sees if the height      // difference between the left and right subtree is equal to or less than      // k. If so, it continues the check for a BST. If not, the method      // immediately returns false.  	private boolean isBalanced(int k, BinaryNode<T> n)  	{  		if (n == null)  			return true;  		int leftHeight = getHeight(n.getLeftChild());		int rightHeight = getHeight(n.getRightChild());		// This will check if the right side and left side height are equal to or below k and then		// recursively check the left and right subtree for balance if the respective children are		// not null.		if (Math.abs(leftHeight-rightHeight) <= k &&				isBalanced(k, n.getLeftChild()) && isBalanced(k, n.getRightChild()))		{			return true;		}		return false;  	}} // end BinaryNode